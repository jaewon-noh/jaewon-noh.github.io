<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>노재원의 블로그</title>
</head>
<body>
<h1>고급 타입</h1>
<h2>Before</h2>
	<pre>
// type guard
abstract class Person {
	abstract study(): boolean;
}

class JW extends Person {
	study(): boolean {
		return true;
	}
	pet(): boolean {
		return true;
	}
}

class YD extends Person {
	study(): boolean {
		return false;
	}
	game(): boolean {
		return true;
	}
}

const personGenerator = () => Math.random() > 0.5 ? new JW() : new YD();
const person = personGenerator();

if ('study' in person) { // 가능
	console.info(person.study());
}

// if (person.game) { // 타입 추론이 안 된 상태에서 property 확인 불가능
// 	console.info(person.study());
// } else if (person.pet) {
// 	console.info(person.study());
// }

// const jwAssertion = person as JW;
// const ydAssertion = person as YD;

// if (ydAssertion.game) { // 타입 추론이 가능해진다.. 근데 항상 true라고 필요없는 코드라 하네..
// 	console.info(person.study());
// } else if (jwAssertion.pet) {
// 	console.info(person.study());
// }

const isYd = (person: YD | JW): person is YD => { // *** is type 의 형태는 boolean을 의미하게 된다. return값이 boolean이어야 한다
	return !((person as YD).game)
};

if (isYd(person)) {
	person.game();
} else {
	person.pet();
}

// const personArr: (YD | JW)[] = [personGenerator(), personGenerator(), personGenerator(), personGenerator()];
// const filteredArr = personArr.filter((person) => isYd(person));
// const filteredArr1 = personArr.filter&lt;YD&gt;(isYd);
// const filteredArr2 = personArr.filter&lt;YD&gt;((person: YD | JW) => isYd(person));

// typeof guard

const test = (param: string | number) => {
	// typeof target === 'string' or typeof target !== 'string' 이 두 구문은 Typescript의 transpile과정에 유효하게 쓰이는 듯.
	// 다만 typeof 로 확인할 수 있는 값이어야 한다. 기본 타입들에 해당 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#description
	if (typeof param === 'string') {
		console.info(param);
	}
	if (typeof param === 'number') {
		console.info(param);
	}
};

const test2 = (param: YD | JW) => {
	if (param instanceof YD) { // typeof와 마찬가지 맥락
		console.info(param);
	}
	if (param instanceof JW) {
		console.info(param);
	}
}

let nullableTest: number | null | undefined = 1;
console.info(nullableTest); // 찍지 않으면 변수 초기화 불필요하다는 메시지도 주고 좋네
nullableTest = null;
console.info(nullableTest);
nullableTest = undefined;
console.info(nullableTest);

const test3 = (param?: number) => { // optional로 둘 경우 number | undefined의 union type으로 선언되는 것을 확인
	console.info(param);
}

// test3(null);
test3(undefined); // 직접 할당도 가능
test3(); // 안 넣는 것도 가능
test3(1);

const test4 = (param: string): string | undefined => {
	return 'ss' as any;
};

const aa = test4('st');
// aa.trim(); // undefined일 수 있다고 경고 null로 설정해도 null일 수 있다고 경고 뜸.
aa!.trim(); // 타입을 체크하려고 ts를 쓰는데.. 이 기능은 코드상에서 자주 보이면 안될듯.

// type alias는 예제 진행하면서 많이 사용 해봐가지고... skip.. 제네릭, 유니언, 인터섹션 전부 사용 가능하며 기본 타입과 1:1 매칭은 비효율, 비추천.

// type alias와 interface의 비교

// 둘 다 가능한 점

interface human {
	age: number
}

interface yd extends human {
	game: boolean
}

type human1 = { age: number };

type yd1 = human1 & { game: boolean };

// 서로 다른 점

interface robot {
	power: bigint
}

interface robot { // 새 필드 추가 가능
	skin: boolean
}

type robot1 = { power: bigint };
// type robot1 = { skin: boolean }; // 중복 정의 오류

// 문서에서는 객체의 형태라면 interface 그렇지 않다면 type alias를 추천하고 있다.
	</pre>
<h2>After</h2>
	<pre></pre>
</body>
</html>